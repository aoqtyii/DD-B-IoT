# _*_ coding utf-8 _*_
"""
@File : BlockChain_env.py
@Author: yxwang
@Date : 2020/4/16
@Desc :
"""

import os, subprocess, time, signal
import gym
from gym import error, spaces
from gym import utils
from gym.utils import seeding
import numpy as np

from geographical_coordination import geographical_coordination
from stake_distribution import stake_distribution

'''
动作空间: 4维度，分别是验证节点选择，算法选择，区块大小， 时间间隔
状态空间: 单位时间间隔区块大小， 权益分布， 物理节点位置， 物理节点计算能力 
收益范围: 对不同的动作状态有不同的收益
'''

# 未给定值时的默认值
AREA_OF_NODES = (1000, 1000) # 将节点散落的区域假定为规整矩形
N_OF_NODES = 30 # 所有的IIoT节点，N，其中包括block_producer
N_OF_BLOCK_PRODUCER = 21  # 常选择21，block_producer的个数
AVERAGE_TRANSACTION_SIZE = 200  # 200B
STAKE_OF_NODES = (10, 50)  # 对不同的节点权益分配,范围(0, 1)
COMPUTING_RESOURCE_OF_NODE = np.ones(N_OF_NODES, ) * 10  # 暂定为10~30GHz，(generating MACs和verifying MACs)
BLOCK_SIZE_LIMIT = 8 * 1024  # 最大区块的大小限制设定为8M，为统一单位定为B
MAX_BLOCK_INTERVAL = 10  # 最大区块打包间隔时间10s
ETA_S = 0.2
ETA_L = 0.3  # 基尼系数中对去中心化程度的最大限制设定为0.2与0.3
BATCH_SIZE = 3 # 如在PBFT算法中，一个massage中，primary节点处理的request


class BlockChainEnv(gym.Env, utils.EzPickle):
    # Set this in SOME subclasses
    # metadata = {'render.modes': []} # 渲染模式
    reward_range = (-float('inf'), float('inf')) # 收益范围
    spec = None

    # Set these in ALL subclasses
    action_space = None
    observation_space = None

    def __init__(self, n_of_nodes=N_OF_NODES, area_of_nodes=AREA_OF_NODES,
                 average_transaction_size=AVERAGE_TRANSACTION_SIZE,
                 n_of_block_producer=N_OF_BLOCK_PRODUCER, stake_of_nodes=STAKE_OF_NODES,
                 computing_resource_of_node=COMPUTING_RESOURCE_OF_NODE,
                 block_size_limit=BLOCK_SIZE_LIMIT, max_block_interval=MAX_BLOCK_INTERVAL,
                 eta_s=ETA_S, eta_l=ETA_L, batch_size=BATCH_SIZE):
        utils.EzPickle.__init__(self, n_of_nodes, area_of_nodes, average_transaction_size, n_of_block_producer,
                                stake_of_nodes, computing_resource_of_node, block_size_limit, max_block_interval,
                                eta_s, eta_l, batch_size)
        # 定义环境
        self.n_of_nodes = n_of_nodes
        self.area_of_nodes = area_of_nodes
        self.average_transaction_size = average_transaction_size
        self.n_of_block_producer = n_of_block_producer
        self.stake_of_nodes = stake_of_nodes
        self.computing_resource_of_node = computing_resource_of_node
        self.block_size_limit = block_size_limit
        self.max_block_interval = max_block_interval
        self.eta_s = eta_s
        self.eta_l = eta_l
        self.batch_size = batch_size

        # self.observation_space = spaces.Dict({
        #     'average_block_size_per_interval': spaces.Box(low=0, high=200, shape=(1,)),
        #     'stake_of_nodes': spaces.Box(low=0, high=100, shape=(1,)),
        #     'geographical_of_IIoT_nodes': spaces.Box(low=np.array([-1000, -1000]), high=np.array([-1000, -1000])),
        #     'computing_capacity_of_IIoT_nodes': spaces.Box(low=10, high=30, shape=(1,))
        # })

        # 状态集合包括：吞吐量，中心化程度(权益和地理), 地理位置，计算能力，传输率，安全系数
        # OrderedDict([(k, space.sample()) for k, space in self.spaces.items()])
        self.observation_space = spaces.Dict(
            {
            'throughout': spaces.Box(low=0, high=np.inf, shape=(1,)),
            'G_gamma': spaces.Box(low=0, high=1, shape=(1,)),
            'G_lambda': spaces.Box(low=0, high=1, shape=(1,)),
            # 'geographical_of_nodes': spaces.Box(low=np.array([-1000, -1000]), high=np.array([-1000, -1000])),
            'computing_capacity_of_IIoT_nodes': spaces.Box(low=10, high=30, shape=(self.n_of_nodes,)),
            'transmission_rate': spaces.Box(low=10, high=100, shape=(self.n_of_nodes,self.n_of_nodes)),
            'coef_of_security': spaces.Box(low=0, high=1, shape=(1,))
        })

        # 动作空间包括打包节点，共识算法，区块大小，区块间隔
        self.action_space = spaces.Dict({
            # 对所有的节点进行判断，值为1的节点是block_producer
            # 选择共识算法，将不同的共识算法记做0,1,2,3,4...
            # 对于动作空间的选择，连续与离散的区别
            'no_block_producer': spaces.MultiBinary(n_of_nodes),
            'no_consensus_algorithm': spaces.Discrete(3),
            'block_size': spaces.Box(low=0, high=BLOCK_SIZE_LIMIT, shape=(1,)),
            'block_interval': spaces.Box(low=0, high=MAX_BLOCK_INTERVAL, shape=(1,))
        })

        self.seed()

        self.states = []
        self.actions = []

        # self.state = [0.5, 0.5, 0.5, 20, 50, 50]

        # 在observation里，有矩阵的运算，如何在DDPG里处理, self.state类型是orderedDict
        self.state = self.observation_space.sample()

        # 标识是否整个区域里节点位置/个数发生改变
        self.nodes_change = 0

        self.producer_X = []
        self.producer_Y = []

        self.instance_of_geo_coor = geographical_coordination(-self.area_of_nodes[0] / 2, self.area_of_nodes[0] / 2,
                                                         -self.area_of_nodes[1] / 2, self.area_of_nodes[1] / 2,
                                                         self.n_of_nodes)


    # 当经历一个episode后，重新reset state
    def reset(self):
        # self.state = np.concatenate((self.np_random.uniform(low=0, high=1, size=(3,)), self.np_random.uniform(low=10, high=30, size=(self.n_of_nodes,)),
        #                 self.np_random.uniform(low=10, high=50, size=(self.n_of_nodes,self.n_of_nodes)), self.np_random.uniform(low=0, high=100, size=(1,))))
        self.state = self.observation_space.sample()
        return np.array(self.state)

    def step(self, action):
        """
        在完成一幕之后，需要调用reset()重置环境状态：一幕定义为：(1)应用场景改变 (2)某个场景在一段时间内达到较优的效率
        接收到动作之后，返回一个元组，包括（观察到的状态， 收益， 是否结束， 信息）
        Arg:
            action: 通过智能体给出动作，动作的选取是采用soft-epsilon，还是添加noise
        Returns:
            observation (object): 智能体观察到的当前状态
            reward (float) : 根据之前的动作所得到的的收益
            done (bool): 是否达到终止状态
            info (dict): 包括一些辅助信息
        """

        # 初始化状态
        # assert self.action_space.contains(action), "%r (%s) invalid" % (action, type(action))
        s = self.state

        alpha = 0.7
        beta = 0.5
        
        s_ = []
        reward = 0
        # done是作为一个episode结束的标志
        done = False

        # G_gamma, G_lambda, coef_of_security, computing_capacity_of_IIoT_nodes,\
        # throughout, transmission_rate = (s[k] for k in s)
        # 利用初始的状态n_of_nodes=30， n_of_producer_nodes=21， computing_capacity_of_IIoT_nodes=(30,) transmission_rate=(30,30)

        G_gamma, G_lambda, coef_of_security, computing_capacity_of_IIoT_nodes, \
        throughout, transmission_rate = (s[k] for k in s.keys())



        # 通过动作状态中的block_producer的选择，使得G_gamma与G_lambda改变，
        # 同时computing_capacity、transmission_rate、共识算法的选择、区块大小的选择与传输时间有关
        # 动态适应节点的变化，对从较少节点的联盟链共识算法到节点较多的公链共识算法有较好鲁棒性
        no_block_producer = np.count_nonzero(action['no_block_producer'])
        self.index_of_producer = np.argwhere(np.array(action['no_block_producer']) == 1)

        self.n_of_block_producer = no_block_producer
        self.instance_of_geo_coor.n_of_nodes = no_block_producer

        # 获取所有IIoT节点的坐标，IIoT坐标不变，动作选择不同的验证节点(个数、位置)
        if self.nodes_change == 0:
            instance = self.get_Gini()
            G_gamma = instance.get_Gini_stake()
            G_lambda = instance.get_Gini_lambda()
            # self.nodes_X = self.instance_of_geo_coor.geographical_coordinates()[0]
            # self.nodes_Y = self.instance_of_geo_coor.geographical_coordinates()[1]

            # 获取验证节点坐标
            self.producer_X = instance.xx
            self.producer_Y = instance.yy

            self.nodes_change = 1
        if done:
            self.nodes_change = 0

        # # 获取验证节点的坐标
        # for i in index_of_producer[0].tolist():
        #     self.producer_X.append(self.nodes_X[i])
        #     self.producer_Y.append(self.nodes_Y[i])

        throughout = np.floor(action['block_size'] / self.average_transaction_size) / action['block_interval']
        # throughout = np.floor(action[1] / self.average_transaction_size) / action[0]


        '''
        根据动态的选择block_producer的个数与位置(与选择的共识算法是否相关)，计算G_lambda
        '''
        # 在一轮次优化中，计算G_lambda和G_gamma之前，节点的坐标应该固定，现在geo_coor是随机非其次泊松分布获得。
        '''
        根据选择的block_producer的个数，及相关因素，重新分配stake,重新计算G_gamma
        自动调节block_producer的个数
        '''
        # if self.nodes_change == 0:
        #     G_lambda = self.get_Gini()[1]
        #     G_gamma = self.get_Gini()[0]
        #     # self.xy = ((self.get_coordinates()[0][i],self.get_coordinates()[1][i]) for i in range(len(self.get_coordinates())))
        #     self.nodes_X = self.get_coordinates()[0]
        #     self.nodes_Y = self.get_coordinates()[1]
        #     self.nodes_change = 1
        # if done:
        #     self.nodes_change = 0


        coef_of_security = self.get_security_coef(action)

        
        '''
        计算能力，事先对不同的节点赋予不同的计算能力
        '''
        computing_capacity_of_IIoT_nodes = self.get_computing_capacity(action, transmission_rate)
        
        '''
        根据节点位置及block_producer的改变，transmition_rate改变(10~100Mbps)
        是通过模拟，还是通过计算？
        '''
        transmission_rate = self.get_transmission_rate()


        s_ = [G_gamma, G_lambda, coef_of_security, computing_capacity_of_IIoT_nodes,\
        throughout, transmission_rate]
        s_ = {
            'G_gamma':G_gamma,
            'G_lambda':G_lambda,
            'coef_of_security':coef_of_security,
            'computing_capacity_of_IIoT_nodes':computing_capacity_of_IIoT_nodes,
            'throughout':throughout,
            'transmission_rate':transmission_rate
        }
        print(type(s_))
        
        self.state = s_

        # 如何判定是否结束done为True，在一定时间范围内，新策略与旧策略的KL-divergence值小于某个较小的数
        # reward的计算包括throughout、security_coef、G_gamma、G_lambda、还应该包括consensus_time
        if not done:
            if G_gamma < 1 and G_lambda < 1 and coef_of_security < 1:
                reward = beta * throughout + alpha * G_gamma + (1 - alpha) * G_lambda + (1 - beta) * coef_of_security
            else:
                reward = -100
        else:
            reward = 1
        done = bool(
            # TODO 判定结束的条件
        )

        return s_, reward, done, {}

    def get_coordinates(self):
        instance_of_geo_coor = geographical_coordination(-self.area_of_nodes[0] / 2, self.area_of_nodes[0] / 2,
                                                         -self.area_of_nodes[1] / 2, self.area_of_nodes[1] / 2, self.n_of_nodes)

        return instance_of_geo_coor

    # get_Gini需要根据get_coordinates获得的节点进行计算
    def get_Gini(self):
        instance1 = stake_distribution(stake=self.stake_of_nodes, instance_of_geo_coor=self.instance_of_geo_coor)
        # return instance1.get_Gini_stake(), instance1.get_Gini_lambda()
        return instance1

    def get_security_coef(self, action):
        # 共识算法安全性能系数，系数越大越安全
        if action['no_consensus_algorithm'] == 0:
            return 0.7
        elif action['no_consensus_algorithm'] == 1 or action['no_consensus_algorithm'] == 3:
            return 0.2
        elif action['no_consensus_algorithm'] == 2:
            return 0.7

    def get_computing_capacity(self, action, transmission_rate):
        # 判定不同的算法中，所需要的计算能力：
        # client的作用为收集交易ID，生成Merkel Tree，打包成区块并发送至primary
        # primary的作用为收到来自
        if action['no_consensus_algorithm'] != -1:
            # 编号为0的算法是PBFT
            # 首先选择client和primary
            # Alpha:computing_cost_of_verifying_signitures   Beta:computing_cost_of_generating/verifying_MACs
            M = self.batch_size
            Alpha = 2 # MHz
            Beta = 1 # MHz
            f = np.floor((self.n_of_block_producer - 1) / 3)
            K = self.n_of_block_producer
            iop = self.index_of_producer
            '''
                for each batch with bath size M, the primary node needs to verify M signatures 
                and complete 2M + 4 (K − 1) MAC operations
                
                the replica node ; (i != c;p) needs to very M signature and complete M + 4 (K − 1) MAC operations.
                
                Considering the worst case(f<np.floor((k-1)/3)), the computational load per batch for the primary node
                and the replica node are O[primary] = M*Alpha+[2M + 4 (K + f − 1)]*Beta;(The computing cost for verifying signatures and
                generating/verifying MACs,Alpha; Beta, defined as 2MHz/1MHz)
                and O[replica]= M * Alpha + [M + 4 (K + f − 1)]*Beta 
            '''
            # 视图编号
            v = 1

            # Tau: 时间限制
            Tau = 10 # ms

            # arg_primary = v mod |N|, v:视图编号，|N|:节点个数， arg_primary:主节点编号
            arg_primary = np.mod(v, K)

            while True:
                arg_client = np.random.choice(iop.reshape(-1))
                if arg_primary != arg_client:
                    break

            cl_0 = np.zeros((self.n_of_nodes, ))
            # print(type(cl_0))


            # 根据client, primary, replica节点需要产生和验证的MAC，计算节点所需的计算能力
            for i in range(len(iop)):
                if i == arg_primary:
                    cl_0[i] = M * Alpha + (2 * M + 4*(K + f - 1)) * Beta
                    continue
                if i in iop:
                    if i == arg_client:
                        cl_0[i] = M * Alpha + (K + f - 1) * Beta
                        continue
                    # replica nodes
                    cl_0[i] = M * Alpha + (M + 4 * (K + f - 1)) * Beta
            # for i in iop:
            #     if i == arg_primary:
            #         cl_0[i] = M * Alpha + (2  * M + 4 (K + f - 1))*Beta
            #         continue
            #     if i == arg_client:
            #         cl_0[i] = M * Alpha + (K + f - 1) * Beta
            #         continue
            #     # replica nodes
            #     cl_0[i] = M * Alpha + (M + 4*(K + f - 1))*Beta

            Tv = 1 / M * max(cl_0[i] / self.computing_resource_of_node[i] for i in iop if i != arg_client )
            # Td = 1 / M * (min(M * action['block_size'] / transmission_rate[arg_client][arg_primary], Tau) +
            #               min(max(M*action['block_size']/[transmission_rate[arg_primary][i] for i in iop if i not in[arg_primary, arg_client]]), Tau) +
            #               min(max(M*action['block_size']/[transmission_rate[i][j] for i in iop for j in iop if i != arg_client and j != arg_client and i != j]), Tau)+
            #               min(max(M*action['block_size']/[transmission_rate[i][j] for i in iop for j in iop if i != j]), Tau) +
            #               min(max(M*action['block_size']/[transmission_rate[i][arg_client] for i in iop if i != arg_client]), Tau))

            # Td1 = min(M * action['block_size'] / transmission_rate[arg_client][arg_primary], Tau)
            # Td2 = min(max(M*action['block_size']/[transmission_rate[arg_primary][i] for i in iop if i not in[arg_primary, arg_client]]), Tau)
            # Td3 = min(max(M*action['block_size']/[transmission_rate[i][j] for i in iop for j in iop if i != arg_client and j != arg_client and i != j]), Tau)
            # Td4 = min(max(M*action['block_size']/[transmission_rate[i][j] for i in iop for j in iop if i != j]), Tau)
            # Td5 = min(max(M*action['block_size']/[transmission_rate[i][arg_client] for i in iop if i != arg_client]), Tau)
            # Td = 1 / M *(Td1+Td2+Td3+Td4+Td5)
            Td = 1

            return cl_0


        # elif action['no_consensus_algorithm'] == 1:
        #     # 编号为1的算法是Zyzzyva的fast case
        #     M = self.batch_size
        #     Alpha = 2  # MHz
        #     Beta = 1  # MHz
        #     K = self.n_of_block_producer
        #     iop = self.index_of_producer
        #     '''
        #     For Zyaayva algorithm, there exist two cases: (1)fast case: consider there is no faluty nodes, the primary node
        #     needs to verify M signiture and complete 2M+K−1 MAC operations while replica node(i != c;p) requires to
        #     verify M signiture and complete M+1 MAC operations for each batch.
        #
        #     the computational load per batch for the primary node and the replica node are O[primary]= M*Alpha+(2M+K−1)*Beta
        #     and O[replica]= M*Alpha+(M+1)*Beta
        #     '''
        #
        #     # 视图编号
        #     v = 1
        #
        #     # Tau: 时间限制
        #     Tau = 10  # ms
        #
        #     # arg_primary = v mod |N|, v:视图编号，|N|:节点个数， arg_primary:主节点编号
        #     arg_primary = np.mod(v, K)
        #
        #     while True:
        #         arg_client = np.random.choice(iop.reshape(-1))
        #         if arg_primary != arg_client:
        #             break
        #
        #     cl_1 = np.zeros((self.n_of_nodes, ))
        #
        #     # 根据client,primary,replica节点需要产生和验证的MAC，计算节点所需的计算能力
        #     for i in iop:
        #         if i == arg_primary:
        #             cl_1[arg_primary] = M*Alpha+(2*M+K-1)*Beta
        #             continue
        #         if i == arg_client:
        #             cl_1[arg_client] = M*Alpha + (K - 1)*Beta
        #             continue
        #         # replica nodes
        #         cl_1[i] = M*Alpha+(M+1)*Beta
        #
        #     # Tv = 1 / M * max(cl_1[i] / self.computing_resource_of_node[i] for i in iop if i != arg_client )
        #     # Td = 1 / M * (min(M * action['block_size'] / transmission_rate[arg_client][arg_primary], Tau) +
        #     #                   min(max(M * action['block_size'] / transmission_rate[arg_primary][i] for i in iop
        #     #                           if i not in [arg_primary, arg_client]), Tau) +
        #     #                   min(max((M * action['block_size'] / transmission_rate[i][arg_client] for i in iop
        #     #                            if i not in [arg_client])), Tau))
        #
        #     Td1 = min(M * action['block_size'] / transmission_rate[arg_client][arg_primary], Tau)
        #     Td2 = min(max(M * action['block_size'] / transmission_rate[arg_primary][i] for i in iop
        #                               if i not in [arg_primary, arg_client]), Tau)
        #
        #     Td3 = min(max((M * action['block_size'] / transmission_rate[i][arg_client] for i in iop
        #                                if i not in [arg_client])), Tau)
        #
        #     Td = 1 / M * (Td1 + Td2 + Td3)
        #
        #     return cl_1
        #
        # elif action['no_consensus_algorithm'] == 2:
        #     # 编号为2的算法是Zyzzyva的two-phase case
        #     # 首先选择client和primary
        #     M = self.batch_size
        #     Alpha = 2  # MHz
        #     Beta = 1  # MHz
        #     f = np.floor((self.n_of_block_producer - 1) / 3)
        #     K = self.n_of_block_producer
        #     iop = self.index_of_producer
        #     '''
        #     For Zyaayva algorithm two-phase case, accepting faluty nodes of f, the computational load per batch for
        #     the primary node and the replica node are O[primary]= M*Alpha+(4M+K+f−1)*Beta
        #     and O[replica]= M*Alpha+(3M+1)*Beta
        #     '''
        #     # 视图编号
        #     v = 1
        #
        #     # Tau: 时间限制
        #     Tau = 10  # ms
        #
        #     # tr: first case与two phase之间的间隔
        #     tr = 5 # ms
        #
        #     # arg_primary = v mod |N|, v:视图编号，|N|:节点个数， arg_primary:主节点编号
        #     arg_primary = np.mod(v, K)
        #
        #     while True:
        #         arg_client = np.random.choice(iop.reshape(-1))
        #         if arg_primary != arg_client:
        #             break
        #
        #     cl_2 = np.zeros((self.n_of_nodes, ))
        #
        #     # 根据client,primary,replica节点需要产生和验证的MAC，计算节点所需的计算能力
        #     for i in iop:
        #         if i == arg_primary:
        #             cl_2[arg_primary] = M * Alpha + (4 * M + K + f - 1) * Beta
        #             continue
        #         if i == arg_client:
        #             cl_2[arg_client] = K * M * Alpha + (2 * K + f - 2 ) * Beta
        #             continue
        #         # replica nodes
        #         cl_2[i] = M * Alpha + (3 * M + 1) * Beta
        #
        #     Tv = 1 / M * max(
        #             cl_2[i] / self.computing_resource_of_node [i] for i in iop if i != arg_client )
        #     # Td = 1 / M * (min(M * action['block_size'] / transmission_rate[arg_client][arg_primary], Tau) +
        #     #                   min(max(M * action['block_size'] / transmission_rate[arg_primary][i] for i in iop
        #     #                           if i not in [arg_primary, arg_client]), Tau) +
        #     #                   min(max((M * action['block_size'] / transmission_rate[i][arg_client] for i in iop
        #     #                            if i not in [arg_client])), Tau) + tr +
        #     #                   min(max((M * action['block_size'] / transmission_rate[arg_client][i] for i in iop if i not in [arg_client])), Tau) +
        #     #                   min(max((M * action['block_size'] / transmission_rate[i][arg_client] for i in iop if i not in [arg_client])), Tau))
        #
        #     Td1 = min(M * action['block_size'] / transmission_rate[arg_client][arg_primary], Tau)
        #     Td2 = min(max(M * action['block_size'] / transmission_rate[arg_primary][i] for i in iop
        #                               if i not in [arg_primary, arg_client]), Tau)
        #
        #     Td3 = min(max((M * action['block_size'] / transmission_rate[i][arg_client] for i in iop if i not in [arg_client])), Tau)
        #
        #     Td4 = min(max((M * action['block_size'] / transmission_rate[arg_client][i] for i in iop if i not in [arg_client])), Tau)
        #
        #     Td5 = min(max((M * action['block_size'] / transmission_rate[i][arg_client] for i in iop if i not in [arg_client])), Tau)
        #
        #
        #     Td = 1 / M * (Td1 + Td2 + Td3 + tr + Td4 + Td5)
        #
        #     return cl_2
        #
        # elif action['no_consensus_algorithm'] == 3:
        #     # 编号为3的算法是Quorum
        #     # 没有primary节点
        #     Alpha = 2  # MHz
        #     Beta = 1  # MHz
        #     K = self.n_of_block_producer
        #     iop = self.index_of_producer
        #     '''
        #     The robustness of Quorum is poorest among these three protocols since it fails to reach consensus
        #     once there’s any faulty replica (f = 0), The consensus process only involves two phases – Request and Reply.
        #     Note that there’s no primary replica and batching doesn’t work for Quorum.
        #
        #     The computational load per request for the replica k=1,2,...K(k!=c) O[replica] = Alpha + 2Beta
        #     '''
        #
        #     arg_client = np.random.choice(iop.reshape(-1))
        #
        #     cl_3 = np.zeros((self.n_of_nodes, ))
        #
        #     # 计算节点所需的计算能力
        #     for i in iop:
        #         cl_3[i] = Alpha + 2 * Beta
        #
        #     Tv = max(cl_3[i] / self.computing_resource_of_node[i] for i in iop if i != arg_client )
        #     # Td = min(max(action['block_size'] / transmission_rate[arg_client][i] for i in iop if i != arg_client), Tau) +\
        #     #     min(max(action['block_size'] / transmission_rate[i][arg_client] for i in iop), Tau)
        #
        #     Td1 = min(max(action['block_size'] / transmission_rate[arg_client][i] for i in iop if i != arg_client), Tau)
        #     Td2 = min(max(action['block_size'] / transmission_rate[i][arg_client] for i in iop), Tau)
        #     Td = Td1 + Td2
        #
        # elif action['no_consensus_algorithm'] == 4:
        #     # 编号为4的算法是Aardvark
        #     # 首先选择client和primary
        #     M = self.batch_size
        #     Alpha = 2  # MHz
        #     Beta = 1  # MHz
        #     f = np.floor((self.n_of_block_producer - 1) / 3)
        #     K = self.n_of_block_producer
        #     iop = self.n_of_nodes
        #
        #     # 视图编号
        #     v = 1
        #
        #     # Tau: 时间限制
        #     Tau = 10  # ms
        #
        #     # arg_primary = v mod |N|, v:视图编号，|N|:节点个数， arg_primary:主节点编号
        #     arg_primary = np.mod(v, K)
        #
        #     while True:
        #         arg_client = np.random.choice(iop.reshape(-1))
        #         if arg_primary != arg_client:
        #             break
        #
        #     cl_4 = np.zeros((self.n_of_nodes,))
        #
        #     # 根据client, primary, replica节点需要产生和验证的MAC，计算节点所需的计算能力
        #     for i in iop:
        #         if i == arg_primary:
        #             cl_4[arg_primary] = M * Alpha + (2 * M + 4(K + f - 1)) * Beta
        #             continue
        #         if i == arg_client:
        #             cl_4[arg_client] = M * Alpha + (K + f - 1) * Beta
        #             continue
        #         # replica nodes
        #         cl_4[i] = M * Alpha + (M + 4*(K + f - 1)) * Beta
        #
        #     Tv = 1 / M * max(
        #         cl_4[i] / self.computing_resource_of_node[i] for i in iop if i != arg_client)
        #     # Td = 1 / M * (min(M * action['block_size'] / transmission_rate[arg_client][arg_primary], Tau) +
        #     #               min(max(M * action['block_size'] / transmission_rate[arg_primary][i] for i in iop if
        #     #                       i not in [arg_primary, arg_client]), Tau) +
        #     #               min(max(
        #     #                   (M * action['block_size'] / transmission_rate[i][j] for i in iop for j in iop if
        #     #                    i != arg_client and j != arg_client and i != j)), Tau) +
        #     #               min(max(
        #     #                   M * action['block_size'] / transmission_rate[i][j] for i in iop for j in iop if
        #     #                   i != j), Tau) +
        #     #               min(max(M * action['block_size'] / transmission_rate[i][arg_client] for i in iop), Tau))
        #     Td1=min(M * action['block_size'] / transmission_rate[arg_client][arg_primary], Tau)
        #     Td2=min(max(M * action['block_size'] / transmission_rate[arg_primary][i] for i in iop if
        #                           i not in [arg_primary, arg_client]), Tau)
        #     Td3=min(max((M * action['block_size'] / transmission_rate[i][j] for i in iop for j in iop if
        #                        i != arg_client and j != arg_client and i != j)), Tau)
        #     Td4=min(max(M * action['block_size'] / transmission_rate[i][j] for i in iop for j in iop if
        #                       i != j), Tau)
        #     Td5=min(max(M * action['block_size'] / transmission_rate[i][arg_client] for i in iop), Tau)
        #     Td = 1/M*(Td1 + Td2 + Td3  + Td4 + Td5)
        #
        #     return cl_4
        #
        # elif action['no_consensus_algorithm'] == 5:
        #     # 编号为5的算法是RBFT
        #     # 首先选择client和primary
        #     M = self.batch_size
        #     Alpha = 2  # MHz
        #     Beta = 1  # MHz
        #     f = np.floor((self.n_of_block_producer - 1) / 3)
        #     K = self.n_of_block_producer
        #     iop = self.index_of_producer
        #
        #     # arg_primary = v mod |N|, v:视图编号，|N|:节点个数， arg_primary:主节点编号
        #     arg_primary = np.random.choice(iop.reshape(-1))
        #
        #     # 根据client, primary, replica节点需要产生和验证的MAC，计算节点所需的计算能力
        #     for i in iop:
        #         if i == arg_primary:
        #             self.computing_resource_of_node[arg_primary] = M * Alpha + (2 * M + 4(K + f - 1)) * Beta
        #             continue
        #         # replica nodes
        #         self.computing_resource_of_node[i] = M * Alpha + (M + 4(K + f - 1)) * Beta
        #
        # elif action['no_consensus_algorithm'] == 6:
        #     # TODO: 非联盟链的共识算法，一般来说是在节点数较多的情况下进行切换
        #     pass



    def get_transmission_rate(self):
        base_time_latency = 10 # 利用虚拟机或其他方法模拟节点时间通讯的基本延迟

        return 0

    def close(self):
        pass

    def seed(self, seed=None):
        self.np_random, seed = seeding.np_random(seed)
        return [seed]

    def sample(self):
        pass
